{"version":3,"sources":["../../src/index.js","App.js","index.js"],"names":["Point","constructor","x","y","this","toString","toFixed","rnd","boundMin","boundMax","Math","truncate","pos","posMin","posMax","Number","movePoint","pt","rho","r","yMax","getPointAttribute","pattern","tmp","getRange","maxNum","Array","i","renderControlPoints","data","key","RandomBlob","className","opt","numControls","posWindowSize","angleWindowSize","handleWindowSize","style","fill","debug","options","initRadius","size","distance","initAngle","center","point","path","viewBox","width","height","version","baseProfile","xmlns","d","App","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.51248a5f.chunk.js","sourcesContent":["import React from 'react'\r\n\r\nclass Point {\r\n\tconstructor(x, y) {\r\n\t\tthis.x = x\r\n\t\tthis.y = y\r\n\t}\r\n\ttoString() {\r\n\t\treturn `${this.x.toFixed(2)} ${this.y.toFixed(2)}`\r\n\t}\r\n}\r\n\r\nfunction rnd(boundMin, boundMax) {\r\n\treturn boundMin + (Math.random() * (boundMax - boundMin))\r\n}\r\n\r\nfunction truncate(pos, posMin, posMax) {\r\n\tif (posMin == null) posMin = Number.NEGATIVE_INFINITY\r\n\tif (posMax == null) posMax = Number.POSITIVE_INFINITY\r\n\treturn Math.min(Math.max(pos, posMin), posMax)\r\n}\r\n\r\nfunction movePoint(pt, rho, r, { xMin, xMax, yMin, yMax }={}) {\r\n\treturn new Point(truncate(pt.x + r * Math.cos(rho), xMin, xMax),\r\n\t\t\t\t\t\t\t\t\t truncate(pt.y + r * Math.sin(rho), yMin, yMax))\r\n}\r\n\r\nfunction getPointAttribute(pt, pattern) {\r\n\tlet tmp = {}\r\n\ttmp[pattern.replace(\"?\", \"x\")] = pt.x.toFixed(2)\r\n\ttmp[pattern.replace(\"?\", \"y\")] = pt.y.toFixed(2)\r\n\treturn tmp\r\n}\r\n\r\nfunction compareArrays(a, b) {\r\n\tif (a.length !== b.length) return false;\r\n\tfor (let i = 0; i < a.length; i ++) {\r\n\t\tif (a[i] !== b[i]) return false;\r\n\t}\r\n\treturn true;\r\n}\r\n\r\nfunction isAuto(entry) {\r\n\treturn (entry == null || entry === \"auto\")\r\n}\r\n\r\nfunction preProcessOverride(width, height, opt, override) {\r\n\r\n\t// There are essentially two modes: exact (\"p\" and \"r\" modes) and auto (null and \"w\" modes).\r\n\t// So we can first convert all the p's to r's, and all the nulls to w's (with default window size).\r\n\r\n\tfor (let i = 0; i < override.length; i ++) {\r\n\t\tif (isAuto(override[i])) {\r\n\t\t\toverride[i] = {x: null, y: null, angle: null}\r\n\t\t}\r\n\r\n\t\t[\"x\", \"y\", \"angle\"].forEach(k => {\r\n\t\t\tif (isAuto(override[i][k])) {\r\n\t\t\t\tif (k === \"angle\") override[i][k] = [\"w\", opt.angleWindowSize]\r\n\t\t\t\telse override[i][k] = [\"w\", opt.posWindowSize]\r\n\t\t\t\tif (i === 0)\r\n\t\t\t\t\tif (k === \"x\")\r\n\t\t\t\t\t\toverride[i].x = [\"r\", 0, 0]\r\n\t\t\t\tif (i === override.length - 1)\r\n\t\t\t\t\tif (k === \"x\")\r\n\t\t\t\t\t\toverride[i].x = [\"r\", width, width]\r\n\t\t\t}\r\n\t\t\telse if (override[i][k][0] === \"p\") {\r\n\t\t\t\toverride[i][k] = [\"r\", override[i][k][1], override[i][k][1]]\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n\r\n}\r\n\r\nfunction checkOverride(width, opt, override) {\r\n\t// some checks\r\n\tif (override.length !== opt.numControls) {\r\n\t\tconsole.warn(\"Number of control points and the length of the override array are not equal.\"\r\n\t\t\t+ \" \" + \"The numControls option will be disregarded.\")\r\n\t\topt.numControls = override.length\r\n\t}\r\n\t// the endpoints must be [\"r\", x, x]\r\n\tif (!compareArrays(override[0].x, [\"r\", 0, 0])) {\r\n\t\tconsole.error(\"The first element of override array must have x property of [0, 0].\")\r\n\t}\r\n\tif (!compareArrays(override[opt.numControls - 1].x, [\"r\", width, width])) {\r\n\t\tconsole.error(\"The first element of override array must have x property of [0, 0].\")\r\n\t}\r\n}\r\n\r\nfunction convertEndPoints(opt, override) {\r\n\tif (override[0].y[0] === \"w\")\r\n\t\toverride[0].y = [\"r\", opt.leftPos - override[0].y[1]/2, opt.leftPos + override[0].y[1]/2]\r\n\tif (override[opt.numControls - 1].y[0] === \"w\")\r\n\t\toverride[opt.numControls - 1].y = [\"r\", opt.leftPos - override[opt.numControls - 1].y[1]/2, opt.leftPos + override[opt.numControls - 1].y[1]/2]\r\n}\r\n\r\nfunction \tconvertInteriorPoints(width, height, opt, override, initX, slope, intercept) {\r\n\r\n\tfor (let i = 0; i < override.length; i ++) {\r\n\t\t[\"x\", \"y\", \"angle\"].forEach(k => {\r\n\t\t\tif (override[i][k][0] === \"w\") {\r\n\t\t\t\tlet center = null\r\n\t\t\t\tlet wSize = null\r\n\t\t\t\tlet minVal = null\r\n\t\t\t\tlet maxVal = null\r\n\t\t\t\tswitch (k) {\r\n\t\t\t\t\tcase \"angle\":\r\n\t\t\t\t\t\tcenter = Math.atan(slope)\r\n\t\t\t\t\t\twSize = opt.angleWindowSize\r\n\t\t\t\t\t\tminVal = Number.NEGATIVE_INFINITY\r\n\t\t\t\t\t\tmaxVal = Number.POSITIVE_INFINITY\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"x\":\r\n\t\t\t\t\t\tcenter = initX[i]\r\n\t\t\t\t\t\twSize = opt.posWindowSize\r\n\t\t\t\t\t\tminVal = 0\r\n\t\t\t\t\t\tmaxVal = width\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"y\":\r\n\t\t\t\t\t\tcenter = initX[i] * slope + intercept\r\n\t\t\t\t\t\twSize = opt.posWindowSize\r\n\t\t\t\t\t\tminVal = 0\r\n\t\t\t\t\t\tmaxVal = height\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\toverride[i][k] = [\"r\", truncate(center - wSize/2, minVal, maxVal), truncate(center + wSize/2, minVal, maxVal)]\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n\r\n}\r\n\r\nfunction getMinDistance(a) {\r\n\tlet minDistance = Number.POSITIVE_INFINITY\r\n\tfor (let i = 0; i < a.length - 1; i ++) {\r\n\t\tminDistance = Math.min(\r\n\t\t\tminDistance,\r\n\t\t\tMath.sqrt(Math.pow(a[i].point.x - a[i+1].point.x, 2) + Math.pow(a[i].point.y - a[i+1].point.y, 2))\r\n\t\t)\r\n\t}\r\n\treturn minDistance\r\n}\r\n\r\nfunction getRange(maxNum) {\r\n\treturn Array.from(new Array(maxNum), (x, i) => i)\r\n}\r\n\r\nfunction renderControlPoints(data) {\r\n\treturn(\r\n\t\t<React.Fragment>\r\n\t\t\t{data.map((x, i) => {\r\n\t\t\t\treturn(\r\n\t\t\t\t\t<React.Fragment key={\"group \" + i}>\r\n\t\t\t\t\t\t<line {...getPointAttribute(x.ctrl, \"?1\")} {...getPointAttribute(x.ctrl_alt, \"?2\")} key={\"line \" + i} stroke=\"blue\" />\r\n\t\t\t\t\t\t<circle {...getPointAttribute(x.point, \"c?\")} r={4} key={\"center \" + i} />\r\n\t\t\t\t\t\t<circle {...getPointAttribute(x.ctrl, \"c?\")} r={2} key={\"control \" + i} />\r\n\t\t\t\t\t\t<circle {...getPointAttribute(x.ctrl_alt, \"c?\")} r={2} key={\"control_alt \" + i} />\r\n\t\t\t\t\t</React.Fragment>\r\n\t\t\t\t)\r\n\t\t\t})}\r\n\t\t</React.Fragment>\r\n\t)\r\n}\r\n\r\nexport function RandomHLine({ width, height, options, override, className }) {\r\n\r\n\t// Override is an array of objects.\r\n\t// If the entry at position i is null, undefined, or \"auto\", then default is applied.\r\n\t// Each non-auto entry is an object with 3 possible keys: x, y, and angle.\r\n\t// Each key has a value that's an array (or null). The first element of the array\r\n\t// is the \"mode\" of overriding. There are 3 possible (non-null) modes:\r\n\t// \t- null, undefined, or \"auto\"\r\n\t// \t- [\"p\", value]: specify the exact value\r\n\t// \t- [\"w\", value]: specify the size of the window\r\n\t// \t- [\"r\", l_bound, u_bound]: specify the minimum and maximum values\r\n\t\r\n\tconst opt = {\r\n\t\tleftPos: 0.5*height,\r\n\t\trightPos: 0.5*height,\r\n\t\tposWindowSize: 0.2*height,\r\n\t\tangleWindowSize: Math.PI/3,\r\n\t\tnumControls: 2,\r\n\t\tstyleTop: \"none\",\r\n\t\tstyleBottom: \"none\",\r\n\t\tstyleMid: {fill: \"transparent\", stroke: \"black\"},\r\n\t\tclassNameTop: \"\",\r\n\t\tclassNameBottom: \"\",\r\n\t\tclassNameMid: \"\",\r\n\t\tdebug: false,\r\n\t\t...options\r\n\t}\r\n\r\n\tif (opt.debug)\r\n\t\tconsole.log(\"inital opt\", JSON.parse(JSON.stringify(opt)))\r\n\r\n\t// preprocess override\r\n\tif (!override)\r\n\t\toverride = Array(opt.numControls).fill(\"auto\")\r\n\tpreProcessOverride(width, height, opt, override)\r\n\tcheckOverride(width, opt, override)\r\n\tconvertEndPoints(opt, override)\r\n\tif (opt.debug)\r\n\t\tconsole.log(\"post-processed override\", JSON.parse(JSON.stringify(override)))\r\n\r\n\t// figure out x points first\r\n\t// if (opt.debug) {\r\n\t// \tconsole.log(\"0 -\", opt.numControls)\r\n\t// \tconsole.log(\"1.1 -\", [...Array(3).keys()])\r\n\t// \tconsole.log(\"1.2 -\", [...(Array(3).keys())])\r\n\t// \tconsole.log(\"2 -\", Array.from(new Array(3), (x, i) => i))\r\n\t// \tconsole.log(\"3 -\", [0, 1, 2].map(x => x / (opt.numControls - 1) * width))\r\n\t// }\r\n\tlet initX = getRange(opt.numControls).map(x => x / (opt.numControls - 1) * width)\r\n\tif (opt.debug)\r\n\t\tconsole.log(\"initX\", JSON.parse(JSON.stringify(initX)))\r\n\r\n\tlet lastFixed = 0\r\n\t\r\n\tfor (let i = 1; i < opt.numControls; i ++) {\r\n\t\tif (opt.debug) {\r\n\t\t\tconsole.log(\"---\", i)\r\n\t\t}\r\n\t\tif (override[i].x[0] === \"r\") {\r\n\t\t\tinitX[i] = (override[i].x[1] + override[i].x[2]) / 2\r\n\t\t\tif (opt.debug) {\r\n\t\t\t\tconsole.log(i, \"is in r mode...\")\r\n\t\t\t\tconsole.log(i, initX[i])\r\n\t\t\t}\r\n\t\t\tif (i - lastFixed > 1) {\r\n\t\t\t\t// do linear interpolation from the last fixed point\r\n\t\t\t\tconst lengthInBetween = (initX[i] - initX[lastFixed]) / (i - lastFixed)\r\n\t\t\t\tfor (let j = lastFixed + 1; j < i; j ++) {\r\n\t\t\t\t\tinitX[j] = initX[j - 1] + lengthInBetween\r\n\t\t\t\t\tif (opt.debug) {\r\n\t\t\t\t\t\tconsole.log(j, initX[j])\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tlastFixed = i\r\n\t\t}\r\n\t}\r\n\r\n\tif (opt.debug)\r\n\t\tconsole.log(\"initX at the end\", initX)\r\n\r\n\t// init data array\r\n\tlet data = Array(opt.numControls)\r\n\tfor (let i = 0; i < opt.numControls; i ++) {\r\n\t\tdata[i] = {initX: initX[i]}\r\n\t}\r\n\r\n\t// initial slope... first figure out final y's of endpoints\r\n\tconst finalLeft = rnd(override[0].y[1], override[0].y[2])\r\n\tconst finalRight = rnd(override[opt.numControls - 1].y[1], override[opt.numControls - 1].y[2])\r\n\tconst slope = (finalRight - finalLeft) / width\r\n\toverride[0].y = [\"r\", finalLeft, finalLeft]\r\n\toverride[opt.numControls - 1].y = [\"r\", finalRight, finalRight]\r\n\r\n\tconvertInteriorPoints(width, height, opt, override, initX, slope, finalLeft)\r\n\r\n\tfor (let i = 0; i < opt.numControls; i ++) {\r\n\t\tdata[i].angle = rnd(override[i].angle[1], override[i].angle[2])\r\n\t\tdata[i].point = new Point(rnd(override[i].x[1], override[i].x[2]), rnd(override[i].y[1], override[i].y[2]))\r\n\t}\r\n\r\n\tif (opt.debug) \r\n\t\tconsole.log(\"data\", JSON.parse(JSON.stringify(data)))\r\n\tconst distance = getMinDistance(data)\r\n\r\n\tfor (let i = 0; i < opt.numControls; i ++) {\r\n\t\tdata[i].ctrl = movePoint(data[i].point, data[i].angle, -1*distance/2)\r\n\t\tdata[i].ctrl_alt = movePoint(data[i].point, data[i].angle, distance/2)\r\n\t}\r\n\r\n\tif (opt.debug)\r\n\t\tconsole.log(\"data with controls\", data)\r\n\r\n\tlet midCurve = \"C \" + data[0].ctrl_alt + \", \" + data[1].ctrl + \", \" + data[1].point + \" \"\r\n\tfor (let i = 2; i < opt.numControls; i ++) {\r\n\t\tmidCurve += \"S \" + data[i].ctrl + \", \" + data[i].point + \" \"\r\n\t}\r\n\t\r\n\treturn(\r\n\t\t<div className={className}>\r\n\t\t\t<svg viewBox={`0 0 ${width} ${height}`} width={width} height={height}\r\n\t\t\t\t\tversion=\"1.1\" baseProfile=\"full\" xmlns=\"http://www.w3.org/2000/svg\">\r\n\t\t\t\t{opt.styleTop !== \"none\" &&\r\n\t\t\t\t\t<path d={\"M 0 0 \" + \"V \" + data[0].point.y.toFixed(2) + \" \" + midCurve + \"V 0 Z\"}\r\n\t\t\t\t\t\tstyle={opt.styleTop} className={opt.classNameTop} />\r\n\t\t\t\t}\r\n\t\t\t\t{opt.styleBottom !== \"none\" &&\r\n\t\t\t\t\t<path d={\"M 0 \" + height + \" \" + \"V \" + data[0].point.y.toFixed(2) + \" \" + midCurve + \"V \" + height + \" Z\"}\r\n\t\t\t\t\t\tstyle={opt.styleBottom} className={opt.classNameBottom} />\r\n\t\t\t\t}\r\n\t\t\t\t{opt.styleMid !== \"none\" &&\r\n\t\t\t\t\t<path d={\"M 0 \" + data[0].point.y.toFixed(2) + \" \" + midCurve}\r\n\t\t\t\t\t\tstyle={opt.styleMid} className={opt.classNameMid} />\r\n\t\t\t\t}\r\n\t\t\t\t{opt.debug && renderControlPoints(data)}\r\n\t\t\t</svg>\r\n\t\t</div>\r\n\t)\r\n\r\n}\r\n\r\nexport function RandomBlob({ size, options, className }) {\r\n\t\r\n\tconst opt = {\r\n\t\tnumControls: 3,\r\n\t\tposWindowSize: 0.1*size,\r\n\t\tangleWindowSize: Math.PI/3,\r\n\t\thandleWindowSize: 0.5,\r\n\t\tstyle: {fill: \"grey\"},\r\n\t\tclassName: \"\",\r\n\t\tdebug: false,\r\n\t\t...options\r\n\t}\r\n\r\n\tconst initRadius = size/2 - 2*opt.posWindowSize\r\n\tconst distance = 2*Math.PI*initRadius / opt.numControls / 2.5\r\n\r\n\tconst tmp = Math.random() * 2 * Math.PI;\r\n\t// console.log(tmp + 2)\r\n\r\n\tconst initAngle = getRange(opt.numControls).map(x => tmp + x/opt.numControls*2*Math.PI)\r\n\tconst center = new Point(size/2, size/2)\r\n\r\n\tlet data = Array(opt.numControls)\r\n\t\tfor (let i = 0; i < opt.numControls; i ++) {\r\n\t\tdata[i] = {point: movePoint(\r\n\t\t\t\t\t\t\t\t\t\t\t\tmovePoint(center, initAngle[i], initRadius),\r\n\t\t\t\t\t\t\t\t\t\t\t\tMath.random() * Math.PI*2,\r\n\t\t\t\t\t\t\t\t\t\t\t\tMath.random() * opt.posWindowSize)}\r\n\t\tdata[i].angle = rnd(initAngle[i] + Math.PI/2 - opt.angleWindowSize/2, initAngle[i] + Math.PI/2 + opt.angleWindowSize/2)\r\n\t\tdata[i].ctrl = movePoint(data[i].point, data[i].angle, -1*rnd(distance*(1-opt.handleWindowSize), distance*(1+opt.handleWindowSize)))\r\n\t\tdata[i].ctrl_alt = movePoint(data[i].point, data[i].angle, rnd(distance*(1-opt.handleWindowSize), distance*(1+opt.handleWindowSize)))\r\n\t}\r\n\r\n\tlet path = \"M\" + data[0].point + \" \"\r\n\t\t+ \"C \" + data[0].ctrl_alt + \", \" + data[1].ctrl + \", \" + data[1].point + \" \"\r\n\tfor (let i = 2; i < opt.numControls; i ++) {\r\n\t\tpath += \"S \" + data[i].ctrl + \", \" + data[i].point + \" \"\r\n\t}\r\n\tpath += \"S \" + data[0].ctrl + \", \" + data[0].point\r\n\r\n\r\n\treturn(  \r\n\t\t<div className={className}>\r\n\t\t\t<svg viewBox={`0 0 ${size} ${size}`} width={size} height={size}\r\n\t\t\t\t\tversion=\"1.1\" baseProfile=\"full\" xmlns=\"http://www.w3.org/2000/svg\">\r\n\t\t\t\t<path d={path} style={opt.style} className={opt.className} />\r\n\t\t\t\t{opt.debug && renderControlPoints(data)}\r\n\t\t\t</svg>\r\n\t\t</div>\r\n\t)\r\n\r\n}","import React from 'react'\r\n\r\nimport { RandomBlob } from 'react-random-shapes'\r\n\r\nconst App = () => {\r\n  // return <RandomHLine width={600} height={300} options={{numControls: 4, debug: true}} />\r\n  return <RandomBlob size={500} />\r\n}\r\n\r\nexport default App\r\n","import './index.css'\r\n\r\nimport React from 'react'\r\nimport ReactDOM from 'react-dom'\r\nimport App from './App'\r\n\r\nReactDOM.render(<App />, document.getElementById('root'))\r\n"],"sourceRoot":""}